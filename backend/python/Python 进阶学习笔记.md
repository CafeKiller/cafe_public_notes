# Python 进阶学习笔记

> 主要参考资料/书籍/文章:  
> [Python - 100天从新手到大师](https://github.com/jackfrued/Python-100-Days)

## 多进程

Unix和Linux操作系统上提供了 `fork()` 系统调用来创建进程，调用 `fork()` 函数的是父进程，创建出的是子进程，子进程是父进程的一个拷贝，但是子进程拥有自己的PID。`fork()` 函数非常特殊它会返回两次，父进程中可以通过 `fork()` 函数的返回值得到子进程的PID，而子进程中的返回值永远都是0。Python的 `os` 模块提供了 `fork()` 函数。  

由于Windows系统没有 `fork()` 调用，因此要实现跨平台的多进程编程，可以使用`multiprocessing` 模块的 `Process` 类来创建子进程，而且该模块还提供了更高级的封装，例如批量启动进程的进程池（Pool）、用于进程间通信的队列（Queue）和管道（Pipe）等。  

在程序中创建进程的时候，子进程复制了父进程及其所有的数据结构，每个子进程有自己独立的内存空间, 也就是说在使用父进程的变量时, 两个子进程内的数据是不共享的. 如果需要进行子进程之间的通信, 可以使用 `multiprocessing` 模块内的 `Queen`. 它是可以被多个进程共享的队列，底层是通过管道和信号量（semaphore）机制来实现的.  

核心模块: `multiprocessing`、`os`、`Queue`

## 多线程

在Python早期的版本中就引入了thread模块（现在名为_thread）来实现多线程编程，然而该模块过于底层，而且很多功能都没有提供;  

因此目前的多线程开发我们推荐使用threading模块，该模块对多线程编程提供了更好的面向对象的封装。  

使用方式和 `Process` 类似, 直接使用 `Thread` , 但也可以使用继承机制, 创建一个类继承 `Thread`, 并实现一个 `run` 方法.

```python
class DownloadTask(Thread):

    def run(self):
        pass
```

因为多个线程可以共享进程的内存空间，因此要实现多个线程间的通信相对简单，大家能想到的最直接的办法就是设置一个全局变量，多个线程共享这个全局变量即可。  

但是当多个线程共享同一个变量（我们通常称之为“资源”）的时候，很有可能产生不可控的结果从而导致程序失效甚至崩溃。  

如果一个资源被多个线程竞争使用，那么我们通常称之为“临界资源”，对“临界资源”的访问需要加上保护，否则资源会处于“混乱”的状态。  

此时就可以通过“锁”来保护“临界资源”，只有获得“锁”的线程才能访问“临界资源”，而其他没有得到“锁”的线程只能被阻塞起来，直到获得“锁”的线程释放了“锁”，其他线程才有机会获得“锁”，进而访问被保护的“临界资源”。 

比较遗憾的一件事情是Python的多线程并不能发挥CPU的多核特性，这一点只要启动几个执行死循环的线程就可以得到证实了。  

之所以如此，是因为Python的解释器有一个“全局解释器锁”（GIL）的东西，任何线程执行前必须先获得GIL锁，然后每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行，这是一个历史遗留问题。  

核心模块: `threading` `Lock`

## 网络

- 关键相关模块：`requests`、`socket`、`json`

## 图像与文档处理

- 关键相关模块：`pillow`、`openpyxl`、`docx`

