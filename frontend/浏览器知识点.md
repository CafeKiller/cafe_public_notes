# 浏览器知识点

> 主要参考资料/书籍/文章:  
> [浏览器工作原理](https://juejin.cn/post/7204806134935306301)
> [构建浏览器工作原理知识体系](https://juejin.cn/post/7341983885726187559)  

## 浏览器中的进程

现在的浏览器基本都是采用多进程架构设计，即一个标签页（也就是一个网页）会启用多个进程，一般至少有如下四个进程：

- 浏览器进程：整个浏览器的主进程，负责协调、控制其他进程；
- 渲染进程（也可以叫内核进程）：负责渲染页面内容的进程；
- 网络进程：负责处理网络请求，每个标签页都共享同一个网络进程，以减少资源占用。
- GPU进程：负责处理浏览器中与图形相关的任务，，例如加速页面绘制、处理 CSS 动画、执行 WebGL 操作等。GPU 进程与渲染进程分离，以提高性能。

除此以外，还可能开辟插件进程，如果页面使用了插件（例如 Flash、Java 等），则会有对应的插件进程。  

> P.S. 前端程序员最需要关注的两个进程分别是: 渲染进程（也叫内核进程，因为浏览器内核、js引擎就是在渲染进程中工作的）和网络进程

## 渲染进程中的五类线程

![浏览器进程示意图](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5113a39407c84014aba1b2744a95e8e2~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)

1. GUI渲染线程：负责渲染网页，当页面触发重绘、回流时该线程也会执行；

> 注意：GUI渲染线程和JS引擎线程是互斥的（因为GUI 渲染线程和 JavaScript 引擎线程都需要访问和操作 DOM，所以做了线程安全的处理），当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。这也就是为什么js文件会阻塞页面加载，一般最好放在html底部引入的原因。

2. JS引擎线程：该线程是使用js引擎处理Javascript脚本程序，解析Javascript脚本，运行代码；

3. 事件触发线程：负责处理用户输入和触发相应的事件（例如，点击按钮时，事件触发线程会负责处理这个点击事件）。它管理一个事件队列，当对应的事件被触发时，事件触发线程会把该事件添加到事件队列的队尾，等待JS引擎的处理；

4. 定时器触发线程：负责处理通过 setTimeout 和 setInterval 等方法设置的定时器，触发相应的回调函数。

5. 异步HTTP请求线程：XMLHttpRequest连接后，浏览器会新开一个线程请求，检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将回调函数放入事件队列中，等待JS引擎空闲后执行；

> 为什么事件触发、定时器触发、异步异步HTTP请求都会有各自的线程处理呢？因为JS引擎是单线程的，这些异步任务会阻塞js的执行。所以要单独开启几个线程和主线程并行执行。  
> 这些处理异步操作的线程会把所有异步任务推到一个任务队列里，等待 JS 引擎空闲时，再把他们添加到可执行栈中，开始执行（这里就又延伸到 Event Loop 的机制了）

### 渲染进程中的异步HTTP请求线程和网络进程有何区别?

**渲染进程中的异步 HTTP 请求线程** 是专门用来处理 JavaScript 层面的异步网络请求的，例如使用XMLHttpRequest 对象或 Fetch API。而 **网络进程** 就比较全面了，它负责处理所有的网络操作，包括页面导航、处理主页面的请求、子页面的请求、资源加载等。  

另外他们两个是协同工作的，例如 JS 发起的异步网络请求，要经历：DNS 解析：-> 建立连接 -> 发送请求 -> 接收响应  

当HTTP 异步请求线程处理 JS 代码发起的请求时，DNS 解析和建立连接通常在网络进程中执行，HTTP 异步请求线程则负责发送请求和接收响应。  

## 事件循环机制Event Loop

> 上面我们说了事件循环机制基于 JS 线程是单线程的。虽然渲染进程有很多线程，但是JavaScript执行是在一个单一的线程中进行的。

事件循环的过程：

- 主线程的任务是不断地执行执行栈中的代码。
- 当执行栈为空时，会检查任务队列中是否有待执行的任务。
- 如果有，将任务队列中的回调函数添加到执行栈，继续执行。

> 从上面渲染引擎的几大线程角度来说，JS事件循环机制可以这么理解：  
> 当 JS 引擎从上至下按顺序执行代码时，遇到异步任务，会交由其他几个负责异步任务的线程去执行（事件触发线程、定时器线程、异步Http请求线程）并将异步回调推到任务队列里。

快速理解事件循环机制：

- 任务队列有两组，一个是宏任务队列，一个是微任务队列，定时器线程会把定时器回调推到宏任务队列，其他异步任务都会被推到微任务队列；
- 执行时是执行一个宏任务，然后执行这个宏任务里产生的所有微任务，然后再执行一个宏任务，再执行这个宏任务里产生的所有微任务，一直循环下去；
- 其实你可以这么理解，把定时器的回调内容不要当作异步代码，只是被延迟执行的同步代码。上一点就可以理解成执行完所有同步任务，执行所有产生的异步任务，然后再执行所有同步任务，再执行产生的所有异步任务；
- 最后超简单的理解，你可以这么想，忽略宏任务里的setImmediate（node.js的函数，浏览器中不存在）、I/O 操作等，在浏览器中，宏任务其实只需要关注定时器、延时器。所以可以这么想：JS 从上向下执行，同步代码执行完后，执行除了定时器以外的所有异步任务，然后执行一个定时器，再执行所有除了定时器以外的所有异步任务，一直往复下去...

![事件循环示意图](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0deaba05caa64431ae7ca8287c0c7c5e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)

## 网络进程中的各个线程

- DNS 解析线程（DNS Thread）： 负责进行 DNS 解析，将域名解析为 IP 地址。
- SSL 线程（SSL Thread）： 处理 SSL/TLS 相关的加密和安全通信。
- 网络请求线程（Network Thread）： 负责处理主要的网络请求和响应，包括接收和发送数据。
- IPC 线程（Inter-Process Communication Thread）： 负责进程间通信。

网络进程的主要工作包括：

- 发起和处理网络请求，包括 HTTP 请求、WebSocket 等。
- 执行 DNS 解析，将域名解析为 IP 地址。
- 建立和管理网络连接。
- 处理安全通信，包括 SSL/TLS 加密。
- 处理缓存，包括 HTTP 缓存的读取和写入。
- 处理文件的读取和写入。
- 与其他进程（如浏览器进程）进行通信。

## 渲染进程的工作

大体如下：  

- HTML 解析： 渲染进程负责解析 HTML 文档，构建 DOM 树；
- CSS 解析： 解析样式表，生成 CSS 规则树（Style Rules / CSSOM ）；
- 合成渲染树： 将 DOM 树和 CSS 规则树合成为渲染树(Render Tree)，该树只包含需要渲染的节点（会去除display:none的元素）；
- 布局（Layout）： 计算每个渲染树节点的几何信息，包括位置和大小，生成布局树；
- 绘制（Paint）： 将渲染树的每个节点绘制到屏幕上，创建位图（Bitmap）；
- 合成（Composite）： 将各个图层按正确的顺序（根据层叠顺序z-index和透明度等因素）合成为最终的页面画面，提高绘制性能；
- 处理用户输入： 监听用户输入事件（鼠标点击、键盘输入等），并触发相应的事件处理程序；
- 脚本执行： 执行页面中的 JavaScript 脚本，响应用户交互、更新页面内容；
- 处理网络请求： 处理页面发起的网络请求，包括获取 HTML、CSS、JavaScript 文件等；
- 插件管理： 如果页面使用了插件（如 Flash、PDF 阅读器等），渲染进程会与插件进行交互；
- 内存管理： 管理渲染进程的内存使用，确保不发生内存泄漏等问题；
- 安全性： 实施浏览器的安全策略，防止恶意脚本和攻击；

## 浏览器内核和JS引擎

以前人们常把浏览器内核分为渲染引擎和 Javascript 引擎。后面有了更明确的区分，浏览器内核单指渲染引擎，Javascript 引擎独立了出来。  

所以浏览器内核，也就是渲染引擎，也可以叫排版引擎。浏览器内核是浏览器最核心的部分，负责对网页语法的解释并渲染（显示）网页。  

Javascript 引擎的主要工作是将Javascript代码转换为快速优化的机器码，以便浏览器或服务器能够解释和执行。另外它还负责执行代码、分配内存以及垃圾回收。