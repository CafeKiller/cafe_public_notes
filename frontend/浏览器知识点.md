# 浏览器知识点

> 主要参考资料/书籍/文章:  
> [浏览器工作原理](https://juejin.cn/post/7204806134935306301)
> [构建浏览器工作原理知识体系](https://juejin.cn/post/7341983885726187559)  

## 浏览器中的进程

现在的浏览器基本都是采用多进程架构设计，即一个标签页（也就是一个网页）会启用多个进程，一般至少有如下四个进程：

- 浏览器进程：整个浏览器的主进程，负责协调、控制其他进程；
- 渲染进程（也可以叫内核进程）：负责渲染页面内容的进程；
- 网络进程：负责处理网络请求，每个标签页都共享同一个网络进程，以减少资源占用。
- GPU进程：负责处理浏览器中与图形相关的任务，，例如加速页面绘制、处理 CSS 动画、执行 WebGL 操作等。GPU 进程与渲染进程分离，以提高性能。

除此以外，还可能开辟插件进程，如果页面使用了插件（例如 Flash、Java 等），则会有对应的插件进程。  

> P.S. 前端程序员最需要关注的两个进程分别是: 渲染进程（也叫内核进程，因为浏览器内核、js引擎就是在渲染进程中工作的）和网络进程

## 渲染进程中的五类线程

![浏览器进程示意图](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5113a39407c84014aba1b2744a95e8e2~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)

1. GUI渲染线程：负责渲染网页，当页面触发重绘、回流时该线程也会执行；

> 注意：GUI渲染线程和JS引擎线程是互斥的（因为GUI 渲染线程和 JavaScript 引擎线程都需要访问和操作 DOM，所以做了线程安全的处理），当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。这也就是为什么js文件会阻塞页面加载，一般最好放在html底部引入的原因。

2. JS引擎线程：该线程是使用js引擎处理Javascript脚本程序，解析Javascript脚本，运行代码；

3. 事件触发线程：负责处理用户输入和触发相应的事件（例如，点击按钮时，事件触发线程会负责处理这个点击事件）。它管理一个事件队列，当对应的事件被触发时，事件触发线程会把该事件添加到事件队列的队尾，等待JS引擎的处理；

4. 定时器触发线程：负责处理通过 setTimeout 和 setInterval 等方法设置的定时器，触发相应的回调函数。

5. 异步HTTP请求线程：XMLHttpRequest连接后，浏览器会新开一个线程请求，检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将回调函数放入事件队列中，等待JS引擎空闲后执行；

> 为什么事件触发、定时器触发、异步异步HTTP请求都会有各自的线程处理呢？因为JS引擎是单线程的，这些异步任务会阻塞js的执行。所以要单独开启几个线程和主线程并行执行。  
> 这些处理异步操作的线程会把所有异步任务推到一个任务队列里，等待 JS 引擎空闲时，再把他们添加到可执行栈中，开始执行（这里就又延伸到 Event Loop 的机制了）

### 渲染进程中的异步HTTP请求线程和网络进程有何区别?

**渲染进程中的异步 HTTP 请求线程** 是专门用来处理 JavaScript 层面的异步网络请求的，例如使用XMLHttpRequest 对象或 Fetch API。而 **网络进程** 就比较全面了，它负责处理所有的网络操作，包括页面导航、处理主页面的请求、子页面的请求、资源加载等。  

另外他们两个是协同工作的，例如 JS 发起的异步网络请求，要经历：DNS 解析：-> 建立连接 -> 发送请求 -> 接收响应  

当HTTP 异步请求线程处理 JS 代码发起的请求时，DNS 解析和建立连接通常在网络进程中执行，HTTP 异步请求线程则负责发送请求和接收响应。  

## 事件循环机制Event Loop

> 上面我们说了事件循环机制基于 JS 线程是单线程的。虽然渲染进程有很多线程，但是JavaScript执行是在一个单一的线程中进行的。

事件循环的过程：

- 主线程的任务是不断地执行执行栈中的代码。
- 当执行栈为空时，会检查任务队列中是否有待执行的任务。
- 如果有，将任务队列中的回调函数添加到执行栈，继续执行。

> 从上面渲染引擎的几大线程角度来说，JS事件循环机制可以这么理解：  
> 当 JS 引擎从上至下按顺序执行代码时，遇到异步任务，会交由其他几个负责异步任务的线程去执行（事件触发线程、定时器线程、异步Http请求线程）并将异步回调推到任务队列里。

快速理解事件循环机制：

- 任务队列有两组，一个是宏任务队列，一个是微任务队列，定时器线程会把定时器回调推到宏任务队列，其他异步任务都会被推到微任务队列；
- 执行时是执行一个宏任务，然后执行这个宏任务里产生的所有微任务，然后再执行一个宏任务，再执行这个宏任务里产生的所有微任务，一直循环下去；
- 其实你可以这么理解，把定时器的回调内容不要当作异步代码，只是被延迟执行的同步代码。上一点就可以理解成执行完所有同步任务，执行所有产生的异步任务，然后再执行所有同步任务，再执行产生的所有异步任务；
- 最后超简单的理解，你可以这么想，忽略宏任务里的setImmediate（node.js的函数，浏览器中不存在）、I/O 操作等，在浏览器中，宏任务其实只需要关注定时器、延时器。所以可以这么想：JS 从上向下执行，同步代码执行完后，执行除了定时器以外的所有异步任务，然后执行一个定时器，再执行所有除了定时器以外的所有异步任务，一直往复下去...

![事件循环示意图](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0deaba05caa64431ae7ca8287c0c7c5e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)

## 网络进程中的各个线程

- DNS 解析线程（DNS Thread）： 负责进行 DNS 解析，将域名解析为 IP 地址。
- SSL 线程（SSL Thread）： 处理 SSL/TLS 相关的加密和安全通信。
- 网络请求线程（Network Thread）： 负责处理主要的网络请求和响应，包括接收和发送数据。
- IPC 线程（Inter-Process Communication Thread）： 负责进程间通信。

网络进程的主要工作包括：

- 发起和处理网络请求，包括 HTTP 请求、WebSocket 等。
- 执行 DNS 解析，将域名解析为 IP 地址。
- 建立和管理网络连接。
- 处理安全通信，包括 SSL/TLS 加密。
- 处理缓存，包括 HTTP 缓存的读取和写入。
- 处理文件的读取和写入。
- 与其他进程（如浏览器进程）进行通信。

## 渲染进程的工作

大体如下：  

- HTML 解析： 渲染进程负责解析 HTML 文档，构建 DOM 树；
- CSS 解析： 解析样式表，生成 CSS 规则树（Style Rules / CSSOM ）；
- 合成渲染树： 将 DOM 树和 CSS 规则树合成为渲染树(Render Tree)，该树只包含需要渲染的节点（会去除display:none的元素）；
- 布局（Layout）： 计算每个渲染树节点的几何信息，包括位置和大小，生成布局树；
- 绘制（Paint）： 将渲染树的每个节点绘制到屏幕上，创建位图（Bitmap）；
- 合成（Composite）： 将各个图层按正确的顺序（根据层叠顺序z-index和透明度等因素）合成为最终的页面画面，提高绘制性能；
- 处理用户输入： 监听用户输入事件（鼠标点击、键盘输入等），并触发相应的事件处理程序；
- 脚本执行： 执行页面中的 JavaScript 脚本，响应用户交互、更新页面内容；
- 处理网络请求： 处理页面发起的网络请求，包括获取 HTML、CSS、JavaScript 文件等；
- 插件管理： 如果页面使用了插件（如 Flash、PDF 阅读器等），渲染进程会与插件进行交互；
- 内存管理： 管理渲染进程的内存使用，确保不发生内存泄漏等问题；
- 安全性： 实施浏览器的安全策略，防止恶意脚本和攻击；

## 浏览器内核和JS引擎

以前人们常把浏览器内核分为渲染引擎和 Javascript 引擎。后面有了更明确的区分，浏览器内核单指渲染引擎，Javascript 引擎独立了出来。  

所以浏览器内核，也就是渲染引擎，也可以叫排版引擎。浏览器内核是浏览器最核心的部分，负责对网页语法的解释并渲染（显示）网页。  

Javascript 引擎的主要工作是将Javascript代码转换为快速优化的机器码，以便浏览器或服务器能够解释和执行。另外它还负责执行代码、分配内存以及垃圾回收。

## 渲染进程和浏览器引擎的关系

> 之前说过，浏览器渲染进程有5大类线程：GUI渲染线程、JS引擎线程、事件触发线程、定时器线程、异步HTTP请求线程。

GUI渲染线程是基于渲染引擎工作的，JS引擎线程是基于 JS 引擎工作的，而其他三个线程是浏览器内部机制在处理。  

所以说浏览器渲染进程与浏览器引擎之间的关系是协同工作的关系，共同实现了浏览器的核心功能。  


## 渲染引擎的工作流程

- HTML解析： 浏览器内核的 HTML Parse 将 HTML 转化为DOM树（DOM Tree）;

- css解析： 同时CSS Parse 将css转化为 Cssom Tree（Style Rules）,可以用 document.styleSheets 查看除了内联和默认样式之外的所有内部和外部样式表**；

- 生成渲染树： 然后 DOM树（DOM Tree）和CSS规则（Style Rules）通过附加（Attachment）生成渲染树（Render Tree），设置了display: none的元素会在渲染树中去除。  
这期间会进行样式计算，很多预设值会变成绝对值，比如red会变成rgb(255,0,0)；相对单位会变成绝对单位，比如rem会变成px。日常开发想查看我们预设值计算出来的实际值，可以点击属性右键查看计算得出的值，当然你也可以切换计算样式面板查看全部属性计算后的值。

- 布局： 然后计算DOM树中可见元素的几何位置（例如节点的宽高、相对包含块的位置），生成布局树；

- 分层： 渲染主线程会对整个布局树中进行分层。一般滚动条、a标签、transform、will-change等样式都会影响分层效果，另外，像opacity、filter等属性虽说也能影响分层，但直接设置一般不会有效，需要设置动画animation才会独立分层。`所以如果你想查看哪些元素单独分层了，可以在控制台的图层面板查看`

- 绘制： 渲染引擎将将页面内容绘制到帧缓冲区（Framebuffer）中，帧缓冲区是一个内存区域，用于存储图像数据，这些图像数据最终会被 GPU 渲染到屏幕上。至此，渲染主线程的工作已经完成了，接下来由其他线程处理显示图像；

- 分块： 合成器线程首先对每个图层进行分块，将其划分为更多的小区域；

- 光栅化： 上面我们已经获得了文档结构、元素的样式、元素的几何关系、绘画顺序，接下来把这些信息转化为显示器中的像素才能显示，这个转化的过程，就叫做光栅化。此过程是合成器的光栅工作线程把每个块变成位图，位图可以理解成内存里的一个二维数组，这个二维数组记录了每个像素点信息；

- 合成： 合成器线程再将以上的像素信息生成合成帧，合成帧就是页面一个帧的内容的绘制四边形集合（绘制四边形是包含图块在内存的位置以及图层合成后图块在页面的位置之类的信息）；

- 显示： 最后合成器线程会把出现在视口区的合成帧提交给浏览器进程，即渲染帧，最后浏览器进程将渲染帧发送给GPU从而展示在屏幕上，如果有页面滚动，则合成器线程会构建另外一个合成帧发送给GPU来更新页面；

## JS引擎的工作原理

> 以下为 V8 引擎的工作流程

- 词法分析（Lexical Analysis）： 解析器首先对JavaScript代码进行词法分析，将代码分解为一系列的标记（token）。这些标记是语法上有意义的最小单元，包括关键字、标识符、运算符、分隔符等。

- 语法分析（Syntax Parsing）： 接下来，解析器将标记转化为抽象语法树（Abstract Syntax Tree，简称AST）。AST是代码语法结构的一种抽象表示，便于后续处理。

- 生成字节码（Bytecode Generation）： AST被传递给V8引擎的解释器（Ignition），它将AST转换为字节码。字节码是一种中间表示，不同于机器代码，但比源代码更容易解释和执行。

- 解释执行： 字节码由解释器执行。在这个阶段，代码的基本逻辑会被逐行解释执行。这使得代码能够在不等待整个编译过程完成的情况下开始执行。

- 即时编译（Just-In-Time Compilation，JIT）： 如果引擎检测到某个函数或代码块被频繁执行，它可能会触发即时编译器（TurboFan）来将字节码转换为本机机器代码。本机机器代码的执行速度更快，因此通过JIT编译可以提高性能。

- 优化和内联： 引擎会进行一系列的优化，包括内联缓存、类型反馈等。这些优化旨在使执行更加高效。

- 垃圾回收： 引擎使用垃圾回收器来管理内存，识别不再使用的对象并释放它们。

- 执行结果： 最终，JavaScript代码的执行结果被返回给用户。

### V8 工作流程图

> ![V8 引擎工作流程图](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a4728aa51bd42019b599492a53a6fec~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)

V8 引擎采用了一种称为 “混合执行（Hybrid Execution）” 的策略，将解释执行和即时编译执行结合起来，以在不同情况下实现最佳的性能和响应时间。简单来说就是判断某段代码是否频繁执行，并且有利于性能提升，如果是，则交给TurboFan即时编译器处理，否则还是由解释器执行。  

内联缓存（Inline Caching，简称IC） ：V8 引擎会根据对象的类型和属性访问的上下文动态地生成内联缓存，以避免不必要的查找操作，从而提高访问速度。简单来说，就是在 V8 执行代码时，会把函数中的一些关键数据缓存起来，下次执行该函数时就可以节省获取这个数据的时间了，以提升一些重复代码的执行效率；  

预解析（Pre-Parsing） ：V8 引擎可以在执行 JavaScript 代码之前对其进行预解析，以提前分析代码结构和语法，并生成相应的解析树和抽象语法树（AST）。这可以加速代码的执行过程，尤其是在代码需要频繁执行的情况下。  